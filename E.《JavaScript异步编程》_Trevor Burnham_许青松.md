## 《JavaScript 异步编程》精读笔记

### 写在前面

- 书籍介绍：《JavaScript 异步编程》讲述基本的异步处理技巧，包括 PubSub、事件模式、Promises 等，通过这些技巧，可以更好的应对大型 Web 应用程序的复杂性，交互快速响应的代码。理解了 JavaScript 的异步模式可以让读者写出结构更合理、性能更出色、维护更方便的 JavaScript 程序。
- 我的简评：js 异步编程的科普小书，内容比较全面但不够深入。作为前端开发，了解异步处理机制和优化异步代码非常重要，特别推荐一下《JavaScript 异步编程》。
- ！！福利：文末有 pdf 书籍、笔记思维导图、随书代码打包下载地址哦

### 第一章 深入理解 JavaScript 事件

#### 1.1.事件的调度

- JavaScript 代码用于不会被中断，因为代码在运行期间只需要排队事件即可，而这些事件在代码运行结束之前不会被触发
- JavaScript 事件处理器在线程空闲之前不会运行

#### 1.2.异步函数的类型

- 每一种 JavaScript 环境都有自己的异步函数集
- 在浏览器端，Ajax 方法有一个可设置为 false 的 async 选项
- 在 Node.js 中同步的 API 方法在名称上会有明确的标示如 fs.readFileSync
- WebKit 的 console.log 打印输出并没有立即拍摄对象快照，只存储了一个指向对象的引用，等代码返回事件队列才去打印输出快照
- Node 的 console.log 是严格同步的
- 当同一个 JavaScript 进程正运行着代码时，任何 JavaScript 计时函数都无法使其他代码运行
- setInterval 调度事件设置成 0，chrome 等浏览器触发频率大约为 200 次/秒，node 大约是 1000 次/秒
- 替换成 while 循环时在 Chrome 中触发频率达到 400 万次/秒，在 node 中会达到 500 万次/秒
- 需要更细粒度的计时，在 node 中使用 process.nextTick，在现代浏览器中使用 requestAnimationFrame(主意兼容性)
- http://jsfiddle.net/ TrevorBurnham/SNBYV/

#### 1.3.异步函数的编写

- 要想确认某个函数异步与否，唯一的方法就是审查其源代码
- 有些函数某些时候是异步的，但其他时候却不是
- 大量延时的话，会造成巨大的计算荷载
- 异步递归有一点很害怕，即在等待任务完成期间，可触发延时的次数是不受限的
- 永远不要定义一个潜在同步而返值却有可能用于回调的函数
- 避免使用异步递归

`最佳实践`

1. 请勿依赖那些看似始终异步的函数，除非已经阅读其源代码
2. 请避免使用计时器方法来等待某个会变化的东西
3. 如果同一个函数既返值又运行回调，则请确保回调在返值之后才运行

#### 1.4.异步错误的处理

- JavaScript 也允许抛出异常，随后再用一个 try/catch 语句块捕获
- 利用 try/catch 语句块并不能捕获从异步回调中抛出的错误
- 正因如此，Node.js 中的回调几乎总是接受一个错误作为其首个参数，这样就允许回调自己来决定如何处理这个错误
- 始终记住，只能在回调内部处理源于回调的异步错误
- 在浏览器环境中，windows.onerror 可以捕获异常，如果返回 true，则能阻止浏览器默认的错误处理行为
- 在 node 中，类似的 process 对象的 uncaughtException 事件捕获错误，正常情况下，node 应用会因未捕获的异常而立即退出
- 但自 Node0.8.4 起，uncaughtException 事件就被废弃了
- domain 对象是事件化对象，它将 throw 转化为 error 事件

#### 1.5.嵌套式回调的解嵌套

- 最常见的反模式做法是，回调内部再嵌套回调
- 嵌套式回调诱惑我们通过添加更多代码来添加更多特性，而不是将这些特性实现为可管理、可重用的代码片段
- 按照惯例，请避免两层以上的函数嵌套

### 第二章 分布式事件

- 希望使用分布式事件：事件的蝴蝶偶然扇动下翅膀，整个应用到处都引发反应
- PubSub 意为发布/订阅，模式来分发事件
- PubSub 模式的一些具体表现：Node 的 EventEmitter 对象，Backbone 的事件化模型，JQuery 的自定义事件

#### 2.1.PubSub 模式

- Node 中几乎所有的 I/O 都是 EventEmitter 对象：文件流、HTTP 服务器，甚至是应用进程本身
- 事件处理器本身无法知道自己是从事件队列中还是从应用代码中运行的
- 对于无需即刻发生的事情维持一个队列，并使用一个计时函数定时运行此队列中的下一项任务
- PubSub 简化了事件的命名、分发、堆积

#### 2.2.事件化模型

- 只要对象带有 PubSub 接口，就可以称之为事件化对象
- 每次一个对象上的事件引发了一系列事件并最终对这个对象本身触发了相同的事件，结果就事件循环了
- 事件化模型为我们带来了一种将应用状态变化转换为事件的直观方式

#### 2.3.jQuery 自定义事件

- jQuery 简化了强大分布式事件系统向任何 Web 应用程序的移植
- jQuery 提供了非冒泡式的 triggerHandler 方法
- jQuery 的自定义事件允许直接通过 DOM 来表达 DOM 相关的事件，不必再把 DOM 变化的状态复制到应用程序的其他地方

#### 小结

- PubSub 模式尤其不适合一次性事件
- 用于解决一次性事件问题的工具叫做 Promise

### 第三章 Promise 对象和 Deferred 对象

#### 3.1.Promise 极简史

- Promise 对象也和 EventEmitter 对象一样，允许向同一个事件绑定任意多个处理器(堆积技术)
- 使用 Promise 对象的最大优势在于，可以轻松从现有 Promise 对象派生出新的 Promise
- 在一般性用法中，Promise、Deferred 和 Future 这三个词大体可算作同义词

#### 3.2.生成 Promise 对象

- 准确的说，Deffered 是 Promise 的超集，它比 Promise 多一项关键特性，可以直接触发
- 重申一点：每个 Deferred 对象都含有一个 Promise 对象，而每一个 Promise 对象都代表者一个 Deferred 对象
- Ajax 是演示 Promise 的绝佳用例：每次对远程服务器额调用都或成功或失败，而我们希望以不同的方式来处理这两种情况

#### 3.3.向回调函数传递数据

- 执行或拒绝 Deferred 对象时，提供的任何参数都会转发至相应的回调
- resolve/reject 可以直接将其上下文传递至自己所触发的回调

#### 3.4.进度通知

- jQuery1.7 中为 Promise 对象新添了一种可以调用无数次的回调 progress
- 总结下，Promise 对象接受 3 种回调形式：done、fail、progress

#### 3.5.Promise 对象的合并

- Promise 对象的逻辑合并技术有一个最常见的用例：判定一组异步任务何时完成

#### 3.6.管道连接未来

- JavaScript 中常常无法便捷的执行一系列异步任务，一个主要原因是无法在第一个任务结束之前就向第二个任务附加处理器
- jQuery1.6 为 Promise 对象新增 pipe(管道)方法
- promise.promise() === promise

#### 3.7.jQuery 与 Promises/A 的对比

- jQuery 使用 resolve 作为 fail 的反义词，而 Promise/A 使用的是 fulfill。在 Promise/A 规范中，Promise 对象不管是已履行还是已失败，都是已执行

#### 3.8.用 Promise 对象代替回调函数

- 理想情况下，开始执行异步任务的任何函数都应该返回 Promise 对象
- Promise 大大有助于让意大利面式的回调趋于平滑，而且也是因为 Promise 可以非常轻松的协调这种类型的异步任务

### 第四章 Async.js 的工作流控制

#### 4.1.异步工作流的次序问题

- 普通的异步代码根本无法保证按照做出调用次序来触发调用的回调

#### 4.3.Async.js 的任务组织技术

- Async.js 的数据收集方法解决了一个异步函数如何运用于一个数据集的问题
- 异步函数序列的运行：async.series 和 async.waterfall
- 便利的是 Async.js 按照任务列表的次序向完工事件处理器传递结果，而不是按照生成这些结果的次序
- Async.js 的内核与灵魂：为最常见的异步情景提供简单又省时的工具函数

#### 4.4.异步工作流的动态排队技术

- async.queue 的底层基本理念令人想起 DMV 动态管理视图

### 第五章 worker 对象的多线程技术

#### 5.0.写在前面

- 事件能够代替一种特殊的多线程，即应用程序进程可拆分成多个部分同时运行的多线程技术（或者通过中断技术虚拟实现，或者通过多个 CPU 内核真正实现）
- 尽管只运行在一个线程上确实不理想，但天真的将应用直接分发给多个内核更加糟糕
- 与不同线程进行交互的方式与在 JavaScript 中进行 I/O 操作一摸一样
- 同一个进程内的多个线程之间可以分享状态，而彼此独立的进程之间则不能
- 在 JavaScript 环境中，由 worker 对象运行的并发代码从来不会分享状态

#### 5.1.网页版的 worker 对象

- 首要目标，在不损害 DOM 响应能力的前提下处理复杂的计算
- 几种潜在用法：解码视频、加密通信、解析网页式编辑器
- 基于类似的理由，worker 对象看不到全局的 window 对象和主线程及其他 worker 线程的任何对象
- 通过 postMessage 发送的对象会透明的做序列化和反序列化，想想 JSON.parse 与 JSON.stringify
- worker 对象可以随意使用 XMLHttpRequest
- 还有一个 importScripts 函数可以同步加载并运行指定的脚本

#### 5.2.cluster 带来的 Node 版 worker

- node0.6 后推出一个支持多个进程绑定同一个端口的 API:cluster（群集）
- 通常为追求最佳性能而使用 cluster 按每颗 CPU 内核分化出一个进程
- Node 版 worker 对象由 cluster.fork()把运行自己的同一个脚本再次加载成一个独立的进程
- 浏览器可以将任意多余的线程降格为后台任务，而 node 服务器则要留出计算资源保障其请求处理的主要任务
- 最著名的魔法：多个 worker 对象试图监听一个 TCP 端口时，node 利用内部消息来允许分享该端口
- 同样，cluster 对象有一个主线程和多个 worker 线程，之间基于一些带有序列化对象或附连字符串的事件
- 为了尽可能减少线程之间的通信开销，线程间分享的状态应该存储在像 Redis 这样的外部数据库中

### 第六章 异步的脚本加载

- 需要对脚本分而治之，那些负责让页面更好看、更好用的脚本应该立即加载，而那些可以待会再加载的脚本稍后加载

#### 6.1.局限性与补充说明

- 请尽量避免使用内联技术
- 请勿使用 document.write
- 只要知道 document.write 相当于操控 DOM 时的 GOTO 语句就行了

#### 6.2.script 标签的再认识

- 现代浏览器中的 script 标签分成了两种新类型：经典型和非阻塞型
- 流行将脚本放在页面 body 标签的尾部。一方面用户可以更快的看到页面，另一方面可以主动亲密接触 DOM 而无需等待事件来触发自己
- defer 让我们想到静静等待文档加载的有序排队场景，那么 async 就会让我们想到混乱的无政府状态
- 一个脚本即用 defer 又用 async，则在那些同时支持的浏览器中，async 会覆盖 defer

#### 6.3.可编程的脚本加载

- 两种合理的方法来抓取并运行服务器脚本：生成 Ajax 请求并用 eval 函数处理响应；向 DOM 插入 script 标签
- require.js 强大的工具包能够自动和 AMD 技术一起捋顺哪怕最复杂的脚本依赖图
- 如果要求根据条件来加载脚本，请考虑像 yepnope 这样的脚本加载器。如果站点大量相互依赖的脚本，请考虑 require.js

### 写在后面

- pdf 书籍、笔记思维导图、随书代码打包下载地址：[https://pan.baidu.com/s/1myOqz7WNXeS9pwm-ovmMVg(提取码：vtzc)](https://pan.baidu.com/s/1myOqz7WNXeS9pwm-ovmMVg)
