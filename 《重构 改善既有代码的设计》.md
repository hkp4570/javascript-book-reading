**旧的不变，新的创建，一步切换，旧的再见。**

### 什么是重构

所谓重构（refactoring）是这样一个过程：在不改变 代码外在行为的前提下，对代码做出修改，以改进程序的内部结构，重构就是在代码写好之后改进它的设计

### 第 1 章 重构，第一个示例

#### 1.2

- 差劲的系统是很难修改的，因为很难找到修改点，难以了解做出的修改与现有代码如何协作实现我想要的行 为。如果很难找到修改点，我就很有可能犯错，从而引入 bug
- 如果你要给程序添加一个特性，但发现代码因缺 乏良好的结构而不易于进行更改，那就先重构那个程序， 使其比较容易添加该特性，然后再添加该特性。
- 是需求的变化使重构变得必要。如果一段代码能正常工作，并且不会再被修改，那么完全可以不去重构它。

#### 1.3

- 每当我要进行重构的时候，第一个步骤永远相同：我得确保即将修改的代码拥有一组可靠的测试
- 重构前，先检查自己是否有一套可靠的测试集。这些测试必须有自我检验能力。
- 如果我将这块代码提炼到自己的一个函数里，有哪些变量会离开原本的作用域，不变的作为参数，变化的作为返回值】
- 无论每次重构多么简单，养成重构后即运行测试的习惯非常重要
- 重构技术就是以微小的步伐修改程序。如果你犯下错误，很容易便可发现它。
- 在做任何提炼前，我一般都会先移除局部变量

#### 1.4

- 如果重构引入了性能损耗，先完成重构，再做性能优化

#### 1.6

- 把复杂的代码块分解为更小的单元，与好的命名一样都很重要

#### 1.7

- 编程时，需要遵循营地法则：保证你离开时的代码库一定比来时更健康。

### 第 2 章 重构的原则

#### 2.1

* 重构（名词）：对软件内部结构的一种调整，目的是在 不改变软件可观察行为的前提下，提高其可理解性，降低其 修改成本
* 重构（动词）：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构
* 重构的关键在于运用大量微小且保持软 件行为的步骤，一步步达成大规模的修改

#### 2.2

- 添加新功能时，我不应该修改既有代 码，只管添加新功能。
- 重构时我就不能再添加功能，只管调整代码的结构

#### 2.3

- 消除重复代码，我就可以确定所有事物和行为在代码中只表述一次，这正是优秀设计的根本

#### 2.4

- 重构的最佳时机就在添加新功能之前
- 我需要先理解代码在做什么，然后才能着手修改
- 我已经理解代码在做什么，但发现它做得不好
- 每次要修改时，首先令修改很容易（警告：这件事有时会很难），然后再进行这次容易的修改
- 如果我看见一块凌乱的代码，但并不需要修改它，那么我就不需要重构它
- 如果重写比重构还容易，就别重构了
- 重构的唯一目的就是让我们开发更快，用更少的工作量创造更大的价值
- 如果一块代码我很少触碰，它不会经常给 我带来麻烦，那么我就倾向于不去重构它。如果我还没想清 楚究竟应该如何优化代码，那么我可能会延迟重构

#### 2.5

- 重构的唯一目的就是让我们开发更快，用更少的工作量创造更大的价值
- 如果做一点儿重构能让新功能实现更容易，或者一个问题我已经见过，此时我也会更倾向于重构它
- 不会改变程序可观察的行为，这是重构的一个重要特征

#### 2.7

- 重构的第一块基石是自测试代码
- 所以这三大实践——自测试代码、持续集成、重构——彼此之间有着很强的协同效应
- *YAGNI*这条原则的核心思想就是：不要去设计当前用不到的功能；不要去编写当前用不到的代码。不要做过度设计

#### 2.8

- 先写出可调优的软件，然后调优它以求获得足够的速度。

### 第 3 章 代码的坏味道

- 决定何时重构及何时停止和知道重构机制如何运转一样重要。

#### 3.1 神秘命名

- 改名可能是最常用的重构手法，包括改变函数声明、变量改名、字段改名等

#### 3.2 重复代码

- 如果你在一个以上的地点看到相同的代码结构，那么可以肯定：设法将它们合而为一，程序会变得更好
- 如果重复代码只是相似而不是完全相同，请首先尝试用移动语句重组代码顺序，把相似的部分放在一起以便提炼

#### 3.3 过长函数

- 你应该更积极地分解函数
- 每当感觉需要以注释来说明点什么的时候，我们就把需要说明的东西写进一个独立函数中，并以其用途（而非实现手法）命名
- 如何确定该提炼哪一段代码呢
  - 如果代码前方有一行注释，就是在提醒你：可以将这段代码替换成一个函数
  - 条件表达式和循环常常也是提炼的信号
  - 你应该将循环和循环内的代码提炼到一个独立的函数中

#### 3.4 过长参数列表

- 使用类可以有效地缩短参数列表

#### 3.5 全局数据

- 你把全局数据用一个函数包装起来，至少你就能看见修改它的地方，并开始控制对它的访问

#### 3.6 可变数据

- 如果要更新一个数据结构，就返回一份新的数据副本，旧的数据仍保持不变

- 将没有副作用的代码与执行数据更新操作的代码分开

#### 3.7 发散式变化

- 如果某个模块经常因为不同的原因在不同的方向上发生变化，发散式变化就出现了

#### 3.8 霰弹式修改

- 如果每遇到某种变化，你都必须在许多不同的类内做出许多小修改。你应该使用搬移函数和搬移字段把所有需要修改的代码放进同一个模块里

#### 3.9 依恋情结

- 一个函数跟另一个模块中的函数或者数据交流格外频繁，远胜于在自己所处模块内部的交流

- 判断哪个模块拥有的此函数使用的数据最多，然后就把这个函数和那些数据摆在一起
- 将总是一起变化的东西放在一块儿

#### 3.10 数据泥团

#### 3.11 基本类型偏执

#### 3.12 重复的switch

#### 3.13 循环语句

#### 3.14 冗赘的元素

- 如果有这样一个函数，它的名字就跟实现代码看起来一模一样，通常你只需要使用内联函数

#### 3.15 夸夸其谈通用性

#### 3.16 临时字段

#### 3.17 过长的消息链

#### 3.18 中间人

- 也许某个类的接口有一半的函数都委托给其他类，不必过渡运用委托

#### 3.19 内幕交易

- 减少两个模块之间大量交换数据

#### 3.20 过大的类

#### 3.21 异曲同工的类

#### 3.22 纯数据类

- 所谓纯数据类是指：它们拥有一些字段，以及用于访问（读写）这些字段的函数，除此之外一无长物

#### 3.23 被拒绝的遗赠

#### 3.24 注释

- 当你感觉需要撰写注释时，请先尝试重构，试着让所有注释都变得多余
