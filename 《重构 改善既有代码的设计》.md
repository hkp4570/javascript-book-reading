**旧的不变，新的创建，一步切换，旧的再见。**

### 什么是重构

所谓重构（refactoring）是这样一个过程：在不改变 代码外在行为的前提下，对代码做出修改，以改进程序的内部结构，重构就是在代码写好之后改进它的设计

### 第 1 章 重构，第一个示例

#### 1.2

- 差劲的系统是很难修改的，因为很难找到修改点，难以了解做出的修改与现有代码如何协作实现我想要的行 为。如果很难找到修改点，我就很有可能犯错，从而引入 bug
- 如果你要给程序添加一个特性，但发现代码因缺 乏良好的结构而不易于进行更改，那就先重构那个程序， 使其比较容易添加该特性，然后再添加该特性。
- 是需求的变化使重构变得必要。如果一段代码能正常工作，并且不会再被修改，那么完全可以不去重构它。

#### 1.3

- 每当我要进行重构的时候，第一个步骤永远相同：我得确保即将修改的代码拥有一组可靠的测试
- 重构前，先检查自己是否有一套可靠的测试集。这些测试必须有自我检验能力。
- 如果我将这块代码提炼到自己的一个函数里，有哪些变量会离开原本的作用域，不变的作为参数，变化的作为返回值】
- 无论每次重构多么简单，养成重构后即运行测试的习惯非常重要
- 重构技术就是以微小的步伐修改程序。如果你犯下错误，很容易便可发现它。
- 在做任何提炼前，我一般都会先移除局部变量

#### 1.4

- 如果重构引入了性能损耗，先完成重构，再做性能优化

#### 1.6

- 把复杂的代码块分解为更小的单元，与好的命名一样都很重要

#### 1.7

- 编程时，需要遵循营地法则：保证你离开时的代码库一定比来时更健康。

### 第 2 章 重构的原则

#### 2.1

* 重构（名词）：对软件内部结构的一种调整，目的是在 不改变软件可观察行为的前提下，提高其可理解性，降低其 修改成本
* 重构（动词）：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构
* 重构的关键在于运用大量微小且保持软 件行为的步骤，一步步达成大规模的修改

#### 2.2

- 添加新功能时，我不应该修改既有代 码，只管添加新功能。
- 重构时我就不能再添加功能，只管调整代码的结构

#### 2.3

- 消除重复代码，我就可以确定所有事物和行为在代码中只表述一次，这正是优秀设计的根本

#### 2.4

- 重构的最佳时机就在添加新功能之前
- 我需要先理解代码在做什么，然后才能着手修改
- 我已经理解代码在做什么，但发现它做得不好
- 每次要修改时，首先令修改很容易（警告：这件事有时会很难），然后再进行这次容易的修改
- 如果我看见一块凌乱的代码，但并不需要修改它，那么我就不需要重构它
- 如果重写比重构还容易，就别重构了
- 重构的唯一目的就是让我们开发更快，用更少的工作量创造更大的价值
- 如果一块代码我很少触碰，它不会经常给 我带来麻烦，那么我就倾向于不去重构它。如果我还没想清 楚究竟应该如何优化代码，那么我可能会延迟重构

#### 2.5

- 重构的唯一目的就是让我们开发更快，用更少的工作量创造更大的价值
- 如果做一点儿重构能让新功能实现更容易，或者一个问题我已经见过，此时我也会更倾向于重构它
- 不会改变程序可观察的行为，这是重构的一个重要特征

#### 2.7

- 重构的第一块基石是自测试代码
- 所以这三大实践——自测试代码、持续集成、重构——彼此之间有着很强的协同效应
- *YAGNI*这条原则的核心思想就是：不要去设计当前用不到的功能；不要去编写当前用不到的代码。不要做过度设计

#### 2.8

- 先写出可调优的软件，然后调优它以求获得足够的速度。

